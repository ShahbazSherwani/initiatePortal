// vulnerability-scanner.js - Automated vulnerability scanning system
import { exec } from 'child_process';
import { promisify } from 'util';
import { readFileSync } from 'fs';

const execAsync = promisify(exec);

/**
 * Vulnerability Scanner
 * Scans dependencies for known security vulnerabilities
 */
export class VulnerabilityScanner {
  constructor(db) {
    this.db = db;
  }
  
  /**
   * Run npm audit and parse results
   */
  async scanNpmDependencies() {
    try {
      console.log('üîç Scanning npm dependencies for vulnerabilities...');
      
      const { stdout, stderr } = await execAsync('npm audit --json', {
        maxBuffer: 10 * 1024 * 1024 // 10MB buffer
      });
      
      const auditResult = JSON.parse(stdout);
      
      const vulnerabilities = this.parseNpmAudit(auditResult);
      
      console.log(`‚úÖ Found ${vulnerabilities.length} vulnerabilities`);
      return vulnerabilities;
      
    } catch (error) {
      // npm audit exits with code 1 if vulnerabilities found
      if (error.stdout) {
        try {
          const auditResult = JSON.parse(error.stdout);
          const vulnerabilities = this.parseNpmAudit(auditResult);
          console.log(`‚ö†Ô∏è  Found ${vulnerabilities.length} vulnerabilities`);
          return vulnerabilities;
        } catch (parseError) {
          console.error('Failed to parse npm audit output:', parseError);
          return [];
        }
      }
      console.error('npm audit failed:', error.message);
      return [];
    }
  }
  
  /**
   * Parse npm audit JSON output
   */
  parseNpmAudit(auditResult) {
    const vulnerabilities = [];
    
    if (!auditResult.vulnerabilities) {
      return vulnerabilities;
    }
    
    for (const [packageName, vulnData] of Object.entries(auditResult.vulnerabilities)) {
      const vuln = {
        package: packageName,
        severity: vulnData.severity || 'unknown',
        title: vulnData.via?.[0]?.title || 'Unknown vulnerability',
        description: vulnData.via?.[0]?.url || '',
        cve: this.extractCVE(vulnData),
        version: vulnData.range || 'unknown',
        fixAvailable: vulnData.fixAvailable ? true : false,
        recommendedVersion: vulnData.fixAvailable?.version || null,
        paths: vulnData.effects || [],
        source: 'npm-audit'
      };
      
      vulnerabilities.push(vuln);
    }
    
    return vulnerabilities;
  }
  
  /**
   * Extract CVE identifier from vulnerability data
   */
  extractCVE(vulnData) {
    if (!vulnData.via) return null;
    
    for (const via of vulnData.via) {
      if (typeof via === 'object' && via.url) {
        const cveMatch = via.url.match(/CVE-\d{4}-\d+/);
        if (cveMatch) return cveMatch[0];
      }
    }
    
    return null;
  }
  
  /**
   * Get vulnerability statistics
   */
  getVulnerabilityStats(vulnerabilities) {
    const stats = {
      total: vulnerabilities.length,
      critical: 0,
      high: 0,
      moderate: 0,
      low: 0,
      info: 0,
      fixable: 0
    };
    
    for (const vuln of vulnerabilities) {
      switch (vuln.severity.toLowerCase()) {
        case 'critical':
          stats.critical++;
          break;
        case 'high':
          stats.high++;
          break;
        case 'moderate':
        case 'medium':
          stats.moderate++;
          break;
        case 'low':
          stats.low++;
          break;
        default:
          stats.info++;
      }
      
      if (vuln.fixAvailable) {
        stats.fixable++;
      }
    }
    
    return stats;
  }
  
  /**
   * Save scan results to database
   */
  async saveScanResults(vulnerabilities) {
    try {
      const scanId = await this.createScanRecord(vulnerabilities);
      
      for (const vuln of vulnerabilities) {
        await this.db.query(`
          INSERT INTO vulnerability_scans 
          (scan_id, package_name, severity, title, description, cve, 
           current_version, fix_available, recommended_version, source, created_at)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
        `, [
          scanId,
          vuln.package,
          vuln.severity,
          vuln.title,
          vuln.description,
          vuln.cve,
          vuln.version,
          vuln.fixAvailable,
          vuln.recommendedVersion,
          vuln.source
        ]);
      }
      
      console.log(`üíæ Saved ${vulnerabilities.length} vulnerabilities to database`);
      return scanId;
      
    } catch (error) {
      console.error('Failed to save scan results:', error);
      throw error;
    }
  }
  
  /**
   * Create a new scan record
   */
  async createScanRecord(vulnerabilities) {
    const stats = this.getVulnerabilityStats(vulnerabilities);
    
    const result = await this.db.query(`
      INSERT INTO vulnerability_scan_history 
      (total_vulnerabilities, critical_count, high_count, moderate_count, 
       low_count, fixable_count, scan_date)
      VALUES ($1, $2, $3, $4, $5, $6, NOW())
      RETURNING id
    `, [
      stats.total,
      stats.critical,
      stats.high,
      stats.moderate,
      stats.low,
      stats.fixable
    ]);
    
    return result.rows[0].id;
  }
  
  /**
   * Get latest scan results
   */
  async getLatestScan() {
    try {
      const result = await this.db.query(`
        SELECT * FROM vulnerability_scan_history
        ORDER BY scan_date DESC
        LIMIT 1
      `);
      
      if (result.rows.length === 0) {
        return null;
      }
      
      const scan = result.rows[0];
      
      // Get vulnerabilities for this scan
      const vulnResult = await this.db.query(`
        SELECT * FROM vulnerability_scans
        WHERE scan_id = $1
        ORDER BY 
          CASE severity 
            WHEN 'critical' THEN 1
            WHEN 'high' THEN 2
            WHEN 'moderate' THEN 3
            WHEN 'low' THEN 4
            ELSE 5
          END,
          package_name
      `, [scan.id]);
      
      return {
        ...scan,
        vulnerabilities: vulnResult.rows
      };
      
    } catch (error) {
      console.error('Failed to get latest scan:', error);
      return null;
    }
  }
  
  /**
   * Get scan history
   */
  async getScanHistory(limit = 10) {
    try {
      const result = await this.db.query(`
        SELECT * FROM vulnerability_scan_history
        ORDER BY scan_date DESC
        LIMIT $1
      `, [limit]);
      
      return result.rows;
      
    } catch (error) {
      console.error('Failed to get scan history:', error);
      return [];
    }
  }
  
  /**
   * Check if automatic fixes are available
   */
  async getFixableVulnerabilities() {
    try {
      const latestScan = await this.getLatestScan();
      
      if (!latestScan) {
        return [];
      }
      
      return latestScan.vulnerabilities.filter(v => v.fix_available);
      
    } catch (error) {
      console.error('Failed to get fixable vulnerabilities:', error);
      return [];
    }
  }
  
  /**
   * Generate remediation report
   */
  generateRemediationReport(vulnerabilities) {
    const critical = vulnerabilities.filter(v => v.severity === 'critical');
    const high = vulnerabilities.filter(v => v.severity === 'high');
    const fixable = vulnerabilities.filter(v => v.fixAvailable);
    
    let report = 'üîí VULNERABILITY REMEDIATION REPORT\n';
    report += '=' .repeat(50) + '\n\n';
    
    if (critical.length > 0) {
      report += `üö® CRITICAL (${critical.length}):\n`;
      critical.forEach(v => {
        report += `   - ${v.package}: ${v.title}\n`;
        if (v.fixAvailable) {
          report += `     Fix: npm install ${v.package}@${v.recommendedVersion}\n`;
        }
      });
      report += '\n';
    }
    
    if (high.length > 0) {
      report += `‚ö†Ô∏è  HIGH (${high.length}):\n`;
      high.forEach(v => {
        report += `   - ${v.package}: ${v.title}\n`;
        if (v.fixAvailable) {
          report += `     Fix: npm install ${v.package}@${v.recommendedVersion}\n`;
        }
      });
      report += '\n';
    }
    
    if (fixable.length > 0) {
      report += `‚úÖ AUTO-FIXABLE (${fixable.length}):\n`;
      report += `   Run: npm audit fix\n`;
      report += `   Or: npm audit fix --force (may introduce breaking changes)\n\n`;
    }
    
    report += '=' .repeat(50) + '\n';
    report += `Total vulnerabilities: ${vulnerabilities.length}\n`;
    report += `Fixable: ${fixable.length}\n`;
    
    return report;
  }
  
  /**
   * Send alert for critical vulnerabilities
   */
  async alertCriticalVulnerabilities(vulnerabilities) {
    const critical = vulnerabilities.filter(v => v.severity === 'critical');
    
    if (critical.length === 0) {
      return;
    }
    
    console.error('üö® CRITICAL VULNERABILITIES DETECTED üö®');
    console.error(`Found ${critical.length} critical vulnerabilities:`);
    
    critical.forEach(v => {
      console.error(`  - ${v.package}: ${v.title}`);
      if (v.cve) {
        console.error(`    CVE: ${v.cve}`);
      }
      if (v.fixAvailable) {
        console.error(`    Fix available: ${v.recommendedVersion}`);
      }
    });
    
    // TODO: Send email notification to admins
    // TODO: Create Slack/Teams notification
    // TODO: Create admin dashboard notification
  }
  
  /**
   * Run full security scan
   */
  async runFullScan() {
    console.log('üîê Starting full vulnerability scan...\n');
    
    try {
      // Scan npm dependencies
      const vulnerabilities = await this.scanNpmDependencies();
      
      // Get statistics
      const stats = this.getVulnerabilityStats(vulnerabilities);
      
      // Save to database
      const scanId = await this.saveScanResults(vulnerabilities);
      
      // Generate report
      const report = this.generateRemediationReport(vulnerabilities);
      console.log(report);
      
      // Alert on critical vulnerabilities
      await this.alertCriticalVulnerabilities(vulnerabilities);
      
      return {
        scanId,
        vulnerabilities,
        stats,
        report
      };
      
    } catch (error) {
      console.error('Scan failed:', error);
      throw error;
    }
  }
}

export default VulnerabilityScanner;
